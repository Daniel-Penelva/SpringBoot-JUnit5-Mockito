Metodologia TDD

O TDD (Test-Driven Development), ou Desenvolvimento Orientado a Testes, é uma metodologia de desenvolvimento de software que enfatiza a criação 
de testes automatizados antes da implementação do código de produção. O ciclo de desenvolvimento do TDD é geralmente dividido em três etapas: 
Red-Green-Refactor (Vermelho-Verde-Refatoração).

Aqui está uma visão geral de como o TDD funciona:

1. **Red (Vermelho)**: Na primeira fase, você escreve um teste automatizado que descreve o comportamento desejado de uma parte do sistema que 
   ainda não foi implementada. Esse teste deve falhar inicialmente, indicando que o comportamento ainda não está presente.

2. **Green (Verde)**: Na segunda fase, você escreve o código de produção necessário para que o teste automatizado passe com sucesso. O objetivo 
   é fazer o teste passar de forma simples e direta, sem adicionar funcionalidades extras ou complexidade desnecessária.

3. **Refactor (Refatoração)**: Na terceira fase, você refatora o código recém-implementado, se necessário, para torná-lo mais limpo, eficiente e 
   legível. O objetivo é manter o código de alta qualidade e eliminar qualquer duplicação ou complexidade indesejada.

Este ciclo de Red-Green-Refactor é repetido várias vezes ao longo do desenvolvimento do software, com cada iteração focada em uma pequena parte 
do sistema. O TDD promove várias práticas e benefícios importantes:

- **Testes Automatizados**: O TDD resulta em um conjunto robusto de testes automatizados que podem ser executados a qualquer momento para 
  verificar se as funcionalidades existentes ainda estão funcionando conforme o esperado.

- **Documentação Viva**: Os testes servem como uma forma de documentação viva do código. Eles descrevem claramente o comportamento esperado do 
  software.

- **Refatoração Segura**: A etapa de refatoração é facilitada pelo fato de que você tem um conjunto confiável de testes que podem detectar 
  regressões introduzidas pela refatoração.

- **Feedback Rápido**: Como você está escrevendo testes desde o início, você recebe feedback instantâneo sobre o sucesso ou falha do código, o 
  que ajuda a identificar e corrigir problemas rapidamente.

- **Design Orientado a Testes**: O TDD tende a promover um design de código mais modular e testável, pois você deve escrever testes para partes 
  individuais do sistema desde o início.

- **Foco na Necessidade**: O TDD incentiva você a escrever apenas o código necessário para fazer os testes passarem, o que ajuda a manter o foco 
  nas necessidades reais do software.

O TDD não é uma panaceia e pode não ser apropriado para todos os cenários de desenvolvimento. É especialmente valioso em situações onde a 
qualidade do código é crítica, como em projetos de software com requisitos rigorosos de segurança ou onde a manutenção a longo prazo é um fator 
importante.

No entanto, o TDD também pode ser desafiador e requer prática para ser usado efetivamente. É importante encontrar um equilíbrio entre a criação 
de testes adequados e não gastar tempo excessivo escrevendo testes para cada pequena parte do código. Em última análise, o TDD é uma ferramenta 
poderosa que pode melhorar a qualidade e a confiabilidade do seu software, mas deve ser usado com discernimento e adaptado às necessidades do 
projeto.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação fornecida pelo framework Lombok em Java. Ela é usada para simplificar a criação de construtores complexos, 
especialmente quando uma classe possui muitos campos ou propriedades. O Lombok gera automaticamente um padrão de projeto chamado "Builder" para 
a classe anotada, permitindo a criação de instâncias dessa classe de forma mais concisa e legível.

Aqui está um exemplo de como usar a anotação `@Builder`:

```java
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}

public class Main {
    public static void main(String[] args) {
        Person person = Person.builder()
            .firstName("John")
            .lastName("Doe")
            .age(30)
            .build();
        
        System.out.println(person.getFirstName());
        System.out.println(person.getLastName());
        System.out.println(person.getAge());
    }
}
```

Neste exemplo, a classe `Person` é anotada com `@Builder`. Isso permite que você crie uma instância da classe `Person` usando um padrão fluente, 
onde você pode definir os valores dos campos usando métodos encadeados. No método `main`, você pode ver como é fácil criar uma instância da 
classe `Person` e definir os valores dos campos.

O Lombok gera automaticamente um construtor privado dentro da classe `Person` que aceita todos os campos como argumentos e cria uma instância da 
classe com esses valores. A anotação `@Builder` também adiciona métodos de criação para cada campo, permitindo que você configure esses campos 
individualmente.

Em resumo, a anotação `@Builder` é útil para simplificar a criação de instâncias de classes com muitos campos, melhorando a legibilidade e a 
concisão do código. Ela é especialmente útil em classes de modelo de dados ou classes onde a criação de objetos pode ser complexa devido a muitos 
campos opcionais.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

BDD (Behavior-Driven Development)

O BDD (Behavior-Driven Development), que é uma abordagem de desenvolvimento de software que se concentra em comportamento e colaboração entre 
equipes de desenvolvimento, testes e negócios. BDD é uma extensão do TDD (Test-Driven Development) que visa tornar a compreensão do comportamento 
do software mais clara e compartilhável por todas as partes interessadas, incluindo desenvolvedores, testadores e pessoas de negócios. Aqui estão 
os principais conceitos do BDD:

1. **Linguagem Ubíqua:** Uma parte fundamental do BDD é a criação de uma linguagem compartilhada entre desenvolvedores, testadores e pessoas de 
   negócios. Essa linguagem deve descrever o comportamento esperado do software em termos não técnicos. Isso ajuda a garantir que todos tenham uma 
   compreensão comum do que o software deve fazer.

2. **User Stories:** O BDD frequentemente utiliza "User Stories" para descrever requisitos de software do ponto de vista do usuário final. Essas 
   histórias descrevem como o sistema deve se comportar em termos de entradas, saídas e comportamento esperado.

3. **Especificação por Exemplo:** Uma das práticas-chave do BDD é a criação de "especificações por exemplo". Essas especificações são escritas 
   em linguagem natural e descrevem o comportamento esperado do software em cenários específicos. Esses exemplos ajudam a ilustrar como o 
  software deve se comportar em diferentes situações.

4. **Testes Automatizados:** No BDD, os testes são escritos antes do código de produção. Esses testes são baseados nas especificações por exemplo 
   e servem como uma forma de validar se o código atende aos requisitos.

5. **Ferramentas BDD:** Existem várias ferramentas e estruturas de teste projetadas especificamente para o BDD. Cucumber, Behave e SpecFlow são 
   exemplos de ferramentas populares que permitem escrever testes em linguagem natural e automatizá-los.

6. **Colaboração:** O BDD incentiva a colaboração entre as equipes de desenvolvimento, testes e negócios desde o início do projeto. Isso ajuda a 
   evitar mal-entendidos e garante que todos tenham uma visão clara do que está sendo desenvolvido.

7. **Feedback Contínuo:** Como os testes são escritos antes do código de produção, o BDD fornece feedback contínuo sobre o progresso do 
   desenvolvimento. Isso permite que os problemas sejam identificados e resolvidos mais cedo no processo, economizando tempo e recursos.

8. **Documentação Viva:** As especificações por exemplo servem como documentação viva do sistema. Elas podem ser atualizadas à medida que os 
   requisitos evoluem, garantindo que a documentação esteja sempre alinhada com o código.

Em resumo, o BDD é uma abordagem de desenvolvimento que se concentra em comportamento, colaboração e comunicação eficaz. Ele ajuda a garantir 
que o software atenda aos requisitos do usuário final, promovendo a clareza e a compreensão comuns entre todas as partes interessadas no projeto.

-------------------- // --------------------

O conceito de "Given-When-Then" no contexto do BDD (Behavior-Driven Development).

**BDD (Behavior-Driven Development)** é uma abordagem de desenvolvimento de software que se concentra em descrever o comportamento esperado de 
um sistema a partir da perspectiva do usuário final. Ele promove a colaboração entre desenvolvedores, testadores e partes interessadas para criar 
especificações de comportamento que são compreensíveis tanto para técnicos quanto para não técnicos.

A estrutura "Given-When-Then" é uma parte fundamental do BDD e é usada para estruturar e escrever cenários de teste de forma clara e 
compreensível. Ela é composta por três partes:

1. **Given (Dado):**
   - A primeira parte, "Given," descreve o contexto ou as condições iniciais do cenário de teste. Ou seja, se especifica o cenário, as 
     pré-condições.
   - É onde você configura o ambiente de teste, define o estado inicial e cria qualquer pré-requisito necessário para o cenário.
   - O "Given" estabelece o cenário para o teste.

2. **When (Quando):**
   - A segunda parte, "When," descreve a ação ou o evento que você está testando. Ou seja, as condições das ações que irão ser executadas.
   - É a etapa em que você executa a ação que deseja testar.
   - O "When" representa o comportamento específico que está sendo verificado.

3. **Then (Então):**
   - A terceira parte, "Then," descreve o resultado ou comportamento esperado após a ação ter sido executada. Ou seja, o resultado esperado, as 
     validações a realizar.
   - Aqui, você verifica se o sistema se comportou conforme o esperado e se os resultados são consistentes com as expectativas do teste.
   - O "Then" verifica se o comportamento é o correto.

Exemplo completo de um cenário usando "Given-When-Then":

```
Cenário: sacar dinheiro de um caixa eletrônico

   Dado (Given) que o saldo da conta é de R$ 1000
   E o caixa eletrônico (ATM) contém R$ 500
   Quando (When) o usuário saca R$ 200 no caixa eletrônico
   Então (then) o caixa eletrônico deverá distribuir R$200
   E o saldo da conta deve ser de R$ 800
```

Neste exemplo:
- "Given" configura o estado inicial, ou seja, a conta tem um saldo de R$1000 e o ATM tem R$500.
- "When" descreve a ação, ou seja, o usuário retira R$200 do ATM.
- "Then" especifica o resultado esperado, que o ATM deve liberar R$200 e o saldo da conta deve ser reduzido para R$800.

Outro Exemplo prático:

Given: Dado que o usuário não introduziu nenhuma data no formulário.
When: Quando faz click no botão Enviar.
Then: Se devem mostrar as mensagens de validação apropriadas.


A estrutura "Given-When-Then" ajuda a criar cenários de teste legíveis, compreensíveis e bem estruturados, que são valiosos para as equipes de 
desenvolvimento e teste, bem como para as partes interessadas não técnicas, pois descreve o comportamento do sistema em termos de cenários 
realistas.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação `@ExtendWith(MockitoExtension.class)

A anotação `@ExtendWith(MockitoExtension.class)` é usada em testes unitários do JUnit 5 (JUnit Jupiter) para estender o framework JUnit e 
habilitar a integração com o Mockito, uma biblioteca amplamente usada para criar mocks e simular comportamentos em testes de unidades. 

Quando você adiciona essa anotação a uma classe de teste, como a seguir:

```java
@ExtendWith(MockitoExtension.class)
public class MinhaClasseDeTeste {
    // ...
}
```

Isso indica ao JUnit que ele deve usar a extensão `MockitoExtension` para inicializar objetos mock e injetá-los nas dependências de sua classe 
de teste. Isso é particularmente útil quando você está escrevendo testes que envolvem a criação de mocks e a verificação de interações com esses 
mocks.

Ao usar o `MockitoExtension`, você pode usar facilmente as anotações `@Mock`, `@InjectMocks` e outras para configurar seus mocks e injetá-los 
nas classes que você está testando. Isso ajuda a manter seus testes organizados e facilita a simulação de comportamentos específicos durante os 
testes.

Por exemplo, pode fazer algo como:

```java
@ExtendWith(MockitoExtension.class)
public class MinhaClasseDeTeste {

    @Mock
    private MinhaClasseDependente minhaClasseDependente;

    @InjectMocks
    private MinhaClasse minhaClasse;

    // ...
}
```

Isso configura um mock da classe `MinhaClasseDependente` e injeta-o na classe `MinhaClasse` durante os testes. Dessa forma, você pode controlar 
o comportamento do mock e verificar como a classe `MinhaClasse` interage com sua dependência durante o teste.

Em resumo, `@ExtendWith(MockitoExtension.class)` é uma anotação essencial para integrar o JUnit 5 com o Mockito e facilitar a escrita de testes
unitários envolvendo mocks.


----------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação `@WebMvcTest`

A anotação `@WebMvcTest` é uma anotação fornecida pelo Spring Boot que é usada para escrever testes de unidade para aplicativos da web baseados 
em Spring MVC. Ela é projetada para testar apenas a camada de controlador da sua aplicação, isolando-a do restante do contexto da aplicação. Isso 
é útil quando você deseja testar apenas o comportamento dos controladores web sem a necessidade de configurar todo o contexto de aplicação, como 
serviços, componentes de acesso a dados e outras partes.

Aqui estão algumas características e uso comuns da anotação `@WebMvcTest`:

1. **Escopo Limitado**: A anotação `@WebMvcTest` carrega apenas a camada de controlador da sua aplicação e desabilita automaticamente a 
configuração de outras partes do aplicativo, como serviços, componentes de acesso a dados e filtros globais. Isso ajuda a manter seus testes de 
unidade focados na funcionalidade dos controladores.

2. **Injeção de Dependência de Controladores**: Você pode injetar controladores diretamente em seus testes e testar a lógica de manipulação de 
solicitações HTTP, como roteamento, validação de entrada, etc.

3. **Simulação de Requisições HTTP**: A anotação `@WebMvcTest` fornece um objeto `MockMvc` que permite simular solicitações HTTP, como GET, POST, 
PUT e DELETE, para seus endpoints. Isso permite que você teste como os controladores respondem a diferentes solicitações.

4. **Anotações de Filtragem**: Você pode usar anotações como `@WithMockUser` ou `@WithMockMvcUser` para simular usuários autenticados ou 
autorizados durante os testes.

Em resumo, `@WebMvcTest` é uma anotação útil para escrever testes de unidade para controladores web em aplicativos Spring MVC. Ela fornece um 
ambiente isolado para testar a lógica de controladores, permitindo que você se concentre na funcionalidade da camada de controlador sem carregar 
todo o contexto da aplicação.

-------------------- // --------------------

classe MockMvc

A classe `MockMvc` faz parte do módulo Spring Test do Spring Framework e é uma ferramenta poderosa para testar controladores em aplicativos 
Spring MVC. Ela permite simular solicitações HTTP, interagir com controladores e verificar as respostas geradas por eles, tudo isso sem a 
necessidade de iniciar um servidor web real. Isso torna os testes de controladores muito mais rápidos e eficientes.

Aqui estão algumas das principais funcionalidades e usos da classe `MockMvc`:

1. **Simulação de Solicitações HTTP**: Com o `MockMvc`, você pode simular diferentes tipos de solicitações HTTP, como GET, POST, PUT e DELETE, 
enviando solicitações para os endpoints dos controladores da sua aplicação.

2. **Configuração de Parâmetros e Headers**: Você pode configurar parâmetros de consulta, cabeçalhos e corpo da solicitação para simular 
solicitações específicas. Isso permite testar cenários diferentes e garantir que seus controladores lidem corretamente com diferentes tipos de 
entrada.

3. **Verificação de Respostas**: O `MockMvc` permite verificar as respostas geradas pelos controladores. Você pode verificar o status HTTP da 
resposta, o conteúdo da resposta, os cabeçalhos da resposta e muito mais para garantir que a lógica do controlador esteja funcionando 
corretamente.

4. **Autenticação e Autorização**: Você pode simular cenários de autenticação e autorização usando anotações como `@WithMockUser` para testar 
como seu controlador responde a solicitações de usuários autenticados ou autorizados.

5. **Integração com Bibliotecas de Assertiva**: O `MockMvc` funciona bem com bibliotecas de assertiva, como o JUnit e o AssertJ, para simplificar 
a verificação de resultados nos testes.

Aqui está um exemplo simples qualquer de como usar a classe `MockMvc` para testar um controlador Spring MVC:

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

@WebMvcTest(MeuControlador.class)
public class MeuControladorTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testEndpoint() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/meu-endpoint"))
               .andExpect(MockMvcResultMatchers.status().isOk())
               .andExpect(MockMvcResultMatchers.content().string("Resposta Esperada"));
    }
}
```

Neste exemplo, estamos usando o `MockMvc` para enviar uma solicitação GET para o endpoint "/meu-endpoint" do controlador `MeuControlador`. Em 
seguida, estamos verificando se a resposta possui um status HTTP "200 OK" e se o conteúdo da resposta é igual a "Resposta Esperada".

Em resumo, a classe `MockMvc` é uma ferramenta essencial para escrever testes de controladores em aplicativos Spring MVC. Ela permite que você 
simule solicitações HTTP, teste a lógica do controlador e verifique as respostas geradas de forma eficiente e eficaz. Isso é fundamental para 
garantir que a camada de controlador da sua aplicação funcione conforme o esperado.

-------------------- // --------------------

Anotação @MockBean

A anotação `@MockBean` é uma anotação fornecida pelo Spring Boot e é usada em testes de integração para criar e injetar um bean simulado (mock) 
em seu contexto de aplicação. Ela é frequentemente usada em conjunto com estruturas de teste, como JUnit, para substituir componentes reais de 
sua aplicação por mocks, a fim de isolar o código que está sendo testado e controlar o comportamento de dependências específicas.

Aqui estão os principais usos e características da anotação `@MockBean`:

1. **Simulação de Dependências**: A anotação `@MockBean` é usada para criar um bean simulado que substitui uma dependência real na aplicação 
durante um teste. Isso é útil para isolar o componente que está sendo testado e garantir que ele seja executado independentemente de suas 
dependências.

2. **Injeção Automática**: O bean simulado criado com `@MockBean` é automaticamente injetado no contexto da aplicação durante o teste, 
substituindo qualquer bean com o mesmo tipo no contexto. Isso significa que as classes de teste podem interagir com o mock como se fosse uma 
dependência real.

3. **Configuração de Comportamento**: Você pode configurar o comportamento do bean simulado usando bibliotecas de mock, como Mockito ou EasyMock. 
Isso permite que você especifique como o mock deve responder a chamadas de métodos específicos, retornando valores pré-definidos ou lançando 
exceções.

4. **Teste de Comportamento**: A anotação `@MockBean` é frequentemente usada para testar o comportamento da aplicação quando suas dependências 
retornam valores ou lançam exceções específicas. Isso é útil para verificar como a aplicação lida com diferentes cenários.

5. **Cenários de Teste Complexos**: Você pode usar `@MockBean` para criar mocks de dependências em cenários complexos, como testes de integração 
que envolvem acesso a bancos de dados, serviços externos ou integração com outras partes da aplicação.

Em resumo, a anotação `@MockBean` é uma ferramenta importante para testes de integração em aplicativos Spring Boot. Ela permite criar e 
configurar mocks de dependências, substituindo componentes reais para isolar o código que está sendo testado e controlar o comportamento de 
dependências específicas em cenários de teste. Isso é fundamental para testar o comportamento da aplicação em diferentes condições e cenários.

-------------------- // --------------------

classe ObjectMapper

A classe `ObjectMapper` faz parte da biblioteca Jackson, que é amplamente usada em Java para trabalhar com JSON. O `ObjectMapper` é uma classe 
fundamental para serialização (conversão de objetos Java para JSON) e desserialização (conversão de JSON de volta para objetos Java) de dados. 
Ele oferece uma ampla variedade de recursos e configurações para lidar com operações JSON de maneira flexível e personalizada.

Aqui estão algumas das principais funcionalidades e usos da classe `ObjectMapper`:

1. **Serialização de Objetos Java para JSON**: O `ObjectMapper` permite converter objetos Java em representações JSON. Isso é útil quando você 
deseja enviar dados de um aplicativo Java para outro aplicativo ou serviço que utiliza JSON como formato de troca de dados.

```java
// Converter um objeto Java em JSON
ObjectMapper objectMapper = new ObjectMapper();
String json = objectMapper.writeValueAsString(objetoJava);
```

2. **Desserialização de JSON para Objetos Java**: Você pode usar o `ObjectMapper` para converter dados JSON de volta em objetos Java. Isso é útil 
quando você recebe dados JSON de uma solicitação HTTP ou de uma fonte externa e precisa trabalhar com eles em seu aplicativo Java.

```java
// Converter JSON em um objeto Java
ObjectMapper objectMapper = new ObjectMapper();
MeuObjetoJava objetoJava = objectMapper.readValue(json, MeuObjetoJava.class);
```

3. **Personalização da Serialização e Desserialização**: O `ObjectMapper` permite configurar regras específicas para a serialização e 
desserialização de objetos, como a exclusão de campos específicos, a formatação de datas, a manipulação de valores nulos, etc.

```java
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
```

4. **Manipulação de Tipos Complexos**: O `ObjectMapper` lida bem com tipos complexos, como coleções, mapas, tipos genéricos e classes aninhadas. 
Ele pode serializar e desserializar esses tipos com facilidade.

5. **Suporte a Anotações**: O `ObjectMapper` é compatível com anotações, como `@JsonProperty` e `@JsonIgnore`, que podem ser usadas para 
personalizar a serialização e desserialização de objetos.

6. **Tratamento de Exceções**: O `ObjectMapper` gera exceções específicas, como `JsonParseException` e `JsonMappingException`, quando ocorrem 
erros durante a conversão JSON, permitindo que você trate esses erros de maneira adequada.

7. **Configuração Global**: O `ObjectMapper` pode ser configurado globalmente para definir comportamentos padrão em toda a aplicação, garantindo 
consistência na serialização e desserialização.

```java
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.setDefaultPropertyInclusion(JsonInclude.Include.NON_NULL);
```

O `ObjectMapper` é uma ferramenta essencial ao trabalhar com JSON em aplicativos Java, e sua flexibilidade e recursos avançados o tornam 
amplamente utilizado em desenvolvimento web, APIs RESTful, sistemas de armazenamento de dados e muito mais. Ele oferece controle total sobre 
como os dados são convertidos entre objetos Java e JSON, tornando-o uma escolha valiosa para muitos desenvolvedores.

-------------------- // --------------------

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;

O import `import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;` faz parte do pacote 
`org.springframework.test.web.servlet.request` do framework Spring MVC. Esse import está relacionado ao uso da classe `MockMvcRequestBuilders`, 
que é uma classe utilitária usada para criar objetos que representam solicitações HTTP simuladas ao testar controladores em aplicativos Spring 
MVC.

A anotação `@WebMvcTest`, que mencionamos anteriormente, permite que você injete um objeto `MockMvc` em seus testes de unidade. O `MockMvc` é uma 
classe que permite simular solicitações HTTP para seus endpoints de controlador sem a necessidade de iniciar um servidor web real. Para criar 
solicitações simuladas, você pode usar métodos estáticos da classe `MockMvcRequestBuilders`, que é onde entra o import.

Esses métodos estáticos de `MockMvcRequestBuilders` permitem construir objetos que representam diferentes tipos de solicitações HTTP, como GET, 
POST, PUT, DELETE, entre outros. Cada método estático corresponde a um tipo de solicitação e permite que você especifique o caminho do endpoint, 
os parâmetros da solicitação, o corpo da solicitação (no caso de solicitações POST ou PUT) e outros detalhes da solicitação.

Aqui está um exemplo simples de como usar `MockMvcRequestBuilders` para criar uma solicitação GET simulada:

```java
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

// ...

// Criar uma solicitação GET simulada para o endpoint "/meu-endpoint"
MockMvc mockMvc = MockMvcBuilders.standaloneSetup(meuControlador).build();
mockMvc.perform(MockMvcRequestBuilders.get("/meu-endpoint"))
       .andExpect(MockMvcResultMatchers.status().isOk())
       .andExpect(MockMvcResultMatchers.content().string("Resposta Esperada"));
```

Neste exemplo, `MockMvcRequestBuilders.get("/meu-endpoint")` é usado para criar uma solicitação HTTP GET simulada para o endpoint "/meu-endpoint". 
A solicitação simulada é então enviada ao controlador usando o método `perform` do objeto `MockMvc`.

OBS. Caso queira usar os import static é possível chamar da seguinte maneira, por exemplo, chamando a solicitação 'post':

```java
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;

// ...

// Criar uma solicitação POST simulada para o endpoint "/api/empregados"
ResultActions response = mockMvc.perform(post("/api/empregados")
                .contentType(MediaType.APPLICATION_JSON).content(objectMapper.writeValueAsString(empregado)));
```

Em resumo, o import `import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;` permite o uso conveniente dos métodos 
estáticos da classe `MockMvcRequestBuilders` para criar solicitações HTTP simuladas ao testar controladores Spring MVC em seus testes de unidade. 
Isso facilita a criação e execução de testes para verificar o comportamento de seus endpoints de controlador.

-------------------- // --------------------

Os três imports abaixo estão relacionados ao uso de assertivas (afirmações) em testes de unidade com o framework Spring MVC e JUnit. Eles são 
comumente usados para verificar o comportamento esperado ao testar controladores Spring MVC usando a classe `MockMvc`. 
Vou explicar cada um deles:

1. `import static org.hamcrest.CoreMatchers.is;`: Este import é usado para importar um método estático `is` da classe `CoreMatchers` da 
biblioteca Hamcrest. A biblioteca Hamcrest fornece uma coleção de correspondentes (matchers) que são usados em testes para verificar se os 
resultados obtidos são iguais aos resultados esperados. O `is` é um matcher simples que é usado para verificar se o valor é igual a um valor 
específico.

   Exemplo de uso:
   ```java
   import static org.hamcrest.CoreMatchers.is;
   import static org.hamcrest.MatcherAssert.assertThat;

   // ...

   int resultado = minhaFuncao();
   assertThat(resultado, is(42)); // Verifica se 'resultado' é igual a 42
   ```

OBS. Caso não queira usar os import static é possível chamar diretamente pela Classe 'CoreMatchers', por exemplo:

Exemplo de uso:
   ```java
   import org.hamcrest.CoreMatchers;
   import static org.hamcrest.MatcherAssert.assertThat;

   // ...

   int resultado = minhaFuncao();
   assertThat(resultado, CoreMatchers.is(42)); // Verifica se 'resultado' é igual a 42
   ```

2. `import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;`: Este import é usado para importar vários métodos 
estáticos da classe `MockMvcResultMatchers` do framework Spring Test. Esses métodos são usados para configurar assertivas (afirmações) em testes 
de unidade que envolvem o uso de `MockMvc` para testar controladores Spring MVC.

   Exemplo de uso:
   ```java
   import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
   import org.springframework.test.web.servlet.MockMvc;
   import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
   import org.springframework.test.web.servlet.setup.MockMvcBuilders;

   // ...

   MockMvc mockMvc = MockMvcBuilders.standaloneSetup(meuControlador).build();
   mockMvc.perform(MockMvcRequestBuilders.get("/meu-endpoint"))
          .andExpect(status().isOk()) // Verifica se o status HTTP é OK (200)
          .andExpect(content().string("Resposta Esperada")); // Verifica o conteúdo da resposta
   ```

3. `import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;`: Este import é usado para importar métodos estáticos da 
classe `MockMvcResultHandlers` do framework Spring Test. Esses métodos são usados para adicionar manipuladores de resultados às suas solicitações 
simuladas com `MockMvc`. Os manipuladores de resultados permitem registrar informações sobre a execução das solicitações, o que é útil para 
depuração e diagnóstico.

   Exemplo de uso:
   ```java
   import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;
   import org.springframework.test.web.servlet.MockMvc;
   import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
   import org.springframework.test.web.servlet.setup.MockMvcBuilders;

   // ...

   MockMvc mockMvc = MockMvcBuilders.standaloneSetup(meuControlador).build();
   mockMvc.perform(MockMvcRequestBuilders.get("/meu-endpoint"))
          .andDo(print()); // Imprime informações de resultado para depuração
   ```

Em resumo, esses imports são usados em testes de unidade com Spring MVC e JUnit para realizar as seguintes tarefas:

- `org.hamcrest.CoreMatchers.is` é usado para verificar igualdade de valores.
- `org.springframework.test.web.servlet.result.MockMvcResultMatchers.*` é usado para configurar assertivas em testes de controladores Spring MVC.
- `org.springframework.test.web.servlet.result.MockMvcResultHandlers.*` é usado para adicionar manipuladores de resultados para depuração e 
   diagnóstico.

-------------------- // --------------------

Explicando o método de teste -> testCriarEmpregado()

O método de teste de unidade verifica o comportamento de um endpoint para criar um empregado em um aplicativo Spring Boot que utiliza o framework 
Spring MVC. Vou explicar o que está acontecendo passo a passo:

```java
@Test
void testCriarEmpregado() throws Exception {
    // given
    Empregado empregado = criarEmpregado();
```

Nesta seção, o teste começa configurando o cenário (given). Ele cria uma instância de `Empregado` chamada `empregado` usando um método 
`criarEmpregado()`. Este objeto `empregado` será usado para simular a entrada de dados para o endpoint que está sendo testado.

```java
    given(empregadoServiceMock.salvarEmpregado(any(Empregado.class)))
        .willAnswer((invocation) -> invocation.getArgument(0));
```

Nesta parte, o teste configura um comportamento simulado para o serviço `empregadoServiceMock`. Ele usa o método `given()` do framework Mockito 
para indicar que, quando o método `salvarEmpregado()` do serviço é chamado com qualquer instância de `Empregado` como argumento, ele retornará 
exatamente o mesmo objeto `Empregado`. Isso simula o comportamento de salvar um empregado no serviço, retornando o próprio empregado.

```java
    ResultActions response = mockMvc.perform(post("/api/empregados")
            .contentType(MediaType.APPLICATION_JSON).content(objectMapper.writeValueAsString(empregado)));
```

Nesta parte, o teste usa o objeto `mockMvc` (que é uma instância de `MockMvc` criada anteriormente) para simular uma solicitação POST para o 
endpoint "/api/empregados". Ele configura o tipo de conteúdo da solicitação como JSON e envia os dados do `empregado` como o corpo da solicitação 
após convertê-lo em JSON usando o `objectMapper`.

```java
    // then
    response.andDo(print())
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.nome", is(empregado.getNome())))
            .andExpect(jsonPath("$.sobrenome", is(empregado.getSobrenome())))
            .andExpect(jsonPath("$.email", is(empregado.getEmail())));
```

Na seção "then" do teste, ele começa verificando o resultado da solicitação que foi enviada. Aqui estão as verificações realizadas:

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

- `andExpect(status().isCreated())`: Isso verifica se a resposta possui um status HTTP "201 Created", que geralmente é usado para indicar que um 
   novo recurso foi criado com sucesso.

- `andExpect(jsonPath("$.nome", is(empregado.getNome())))`: Isso verifica se o campo "nome" no corpo da resposta JSON corresponde ao nome do 
   empregado que foi enviado na solicitação.

- `andExpect(jsonPath("$.sobrenome", is(empregado.getSobrenome())))`: Isso verifica se o campo "sobrenome" no corpo da resposta JSON corresponde 
   ao sobrenome do empregado que foi enviado na solicitação.

- `andExpect(jsonPath("$.email", is(empregado.getEmail())))`: Isso verifica se o campo "email" no corpo da resposta JSON corresponde ao email do 
   empregado que foi enviado na solicitação.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados" em seu aplicativo Spring Boot funciona corretamente ao criar um 
empregado. Ele simula a solicitação POST, verifica se a resposta tem o status "201 Created" e verifica se os dados do empregado no corpo da 
resposta correspondem aos dados do empregado que foram enviados na solicitação. Esse tipo de teste é útil para garantir que a funcionalidade de 
criação de empregados esteja funcionando conforme o esperado.

-------------------- // --------------------

willAnswer X willReturn

Ambos os métodos `willAnswer()` e `willReturn()` são métodos usados no framework Mockito para configurar o comportamento de objetos mock 
(simulados) em testes de unidade. Ambos são usados para especificar o que um mock deve fazer quando um método é chamado durante a execução de um 
teste. No entanto, eles têm finalidades ligeiramente diferentes:

1. **`willAnswer()`**:

   - O método `willAnswer()` é usado para configurar um comportamento personalizado quando um método é chamado em um objeto mock.
   
   - Ele permite que você especifique um comportamento personalizado usando uma instância de `Answer`, que é uma interface funcional que 
     representa uma função que pode ser executada quando o método é chamado.

   - `willAnswer()` é útil quando você precisa realizar operações mais complexas, como processar argumentos do método e retornar um valor com 
      base nesses argumentos.

   Exemplo:
   ```java
   given(myMock.someMethod(anyString())).willAnswer(invocation -> {
       String arg = invocation.getArgument(0);
       return "Resposta personalizada para " + arg;
   });
   ```

2. **`willReturn()`**:

   - O método `willReturn()` é usado para especificar um valor de retorno simples quando um método é chamado em um objeto mock.
   
   - Você usa `willReturn()` quando deseja que o mock retorne um valor específico quando um método é chamado, sem a necessidade de realizar 
     qualquer lógica personalizada.

   Exemplo:
   ```java
   given(myMock.someMethod()).willReturn("Valor de retorno esperado");
   ```

Ambos os métodos são usados para definir o comportamento de um objeto mock, mas a escolha entre eles depende da complexidade do comportamento ]
desejado:

- Use `willAnswer()` quando precisar de um comportamento personalizado que envolva lógica mais complexa, como processamento de argumentos ou 
  decisões com base nos argumentos.

- Use `willReturn()` quando desejar que o mock retorne um valor simples e direto sem qualquer processamento adicional.

Em resumo, `willAnswer()` e `willReturn()` são métodos importantes no Mockito para configurar o comportamento de objetos mock em seus testes de 
unidade, permitindo que você simule comportamentos específicos durante a execução dos testes. A escolha entre eles depende da complexidade do 
comportamento que você deseja especificar para o objeto mock.

-------------------- // --------------------

Explicando o método de teste -> testListarEmpregados()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint de listagem de empregados em um aplicativo 
Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. Vou explicar passo a passo o que está acontecendo neste método de 
teste:

```java
void testListarEmpregados() throws Exception {
    // given
    List<Empregado> listaEmpregado = new ArrayList<>();
    listaEmpregado.add(Empregado.builder().nome("Jão").sobrenome("Silva").email("jao@gmail.com").build());
    listaEmpregado.add(Empregado.builder().nome("Patricia").sobrenome("Nunes").email("patricia@gmail.com").build());
    listaEmpregado.add(Empregado.builder().nome("Pedro").sobrenome("Marques").email("pedro@gmail.com").build());

    given(empregadoServiceMock.getAllEmpregados()).willReturn(listaEmpregado);
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria uma lista de objetos `Empregado` chamada `listaEmpregado` com 
três objetos `Empregado` preenchidos com informações fictícias. Essa lista será usada para simular os dados que o serviço `empregadoServiceMock` 
retornará quando o método `getAllEmpregados()` for chamado. O método `given()` do Mockito é usado para especificar que quando `getAllEmpregados()` 
for chamado no serviço, ele deve retornar a lista `listaEmpregado`.

```java
    // when
    ResultActions response = mockMvc.perform(get("/api/empregados"));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação GET para o endpoint 
"/api/empregados", que é o endpoint responsável por listar os empregados.

```java
    // then
    response.andExpect(status().isOk())
            .andDo(print())
            .andExpect(jsonPath("$.size()", is(listaEmpregado.size())));
```

Na seção "then" do teste, ele começa a verificar o resultado da solicitação que foi enviada. Aqui estão as verificações realizadas:

- `response.andExpect(status().isOk())`: Isso verifica se a resposta tem um status HTTP "200 OK", indicando que a solicitação foi bem-sucedida.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

- `response.andExpect(jsonPath("$.size()", is(listaEmpregado.size())))`: Isso verifica se a resposta JSON tem um campo chamado "size" cujo valor 
   é igual ao tamanho da lista `listaEmpregado`. Isso é uma maneira de verificar se a resposta JSON contém o número esperado de empregados.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados" em seu aplicativo Spring Boot está listando os empregados corretamente. 
Ele configura um cenário com dados fictícios, simula uma solicitação GET para o endpoint e verifica se a resposta tem o status HTTP esperado e 
se o tamanho da lista de empregados na resposta corresponde ao tamanho da lista de empregados no cenário configurado. Esse tipo de teste é útil 
para garantir que a funcionalidade de listagem de empregados esteja funcionando conforme o esperado.

-------------------- // --------------------

Explicando o método de teste -> testBuscarEmpregadoPorId()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint para buscar um empregado por ID em um 
aplicativo Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. Vou explicar passo a passo o que está acontecendo neste 
método de teste:

```java
void testBuscarEmpregadoPorId() throws Exception {
    // given
    Empregado empregado = criarEmpregado();
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria um objeto `Empregado` chamado `empregado` usando um método 
`criarEmpregado()` (que provavelmente é definido em algum lugar no código de teste). Este objeto `empregado` será usado para simular um empregado 
que será retornado quando o serviço `empregadoServiceMock` for chamado com um ID específico.

```java
    given(empregadoServiceMock.getEmpregadoById(empregado.getId())).willReturn(Optional.of(empregado));
```

Nesta parte, o teste configura um comportamento simulado para o serviço `empregadoServiceMock`. Ele usa o método `given()` do Mockito para 
indicar que quando o método `getEmpregadoById()` do serviço é chamado com o ID do `empregado`, ele deve retornar um `Optional` contendo o objeto 
`empregado`. Isso simula o comportamento de busca de um empregado pelo ID no serviço.

```java
    // when
    ResultActions response = mockMvc.perform(get("/api/empregados/{id}", empregado.getId()));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação GET para o endpoint 
"/api/empregados/{id}", onde `{id}` é substituído pelo ID do `empregado` criado anteriormente.

```java
    // then
    response.andExpect(status().isOk())
            .andDo(print())
            .andExpect(jsonPath("$.nome", is(empregado.getNome())))
            .andExpect(jsonPath("$.sobrenome", is(empregado.getSobrenome())))
            .andExpect(jsonPath("$.email", is(empregado.getEmail())));
```

Na seção "then" do teste, ele começa a verificar o resultado da solicitação que foi enviada. Aqui estão as verificações realizadas:

- `response.andExpect(status().isOk())`: Isso verifica se a resposta tem um status HTTP "200 OK", indicando que a solicitação foi bem-sucedida.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

- `response.andExpect(jsonPath("$.nome", is(empregado.getNome())))`: Isso verifica se o campo "nome" no corpo da resposta JSON corresponde ao 
   nome do empregado que foi retornado pelo serviço.

- `response.andExpect(jsonPath("$.sobrenome", is(empregado.getSobrenome())))`: Isso verifica se o campo "sobrenome" no corpo da resposta JSON 
   corresponde ao sobrenome do empregado que foi retornado pelo serviço.

- `response.andExpect(jsonPath("$.email", is(empregado.getEmail())))`: Isso verifica se o campo "email" no corpo da resposta JSON corresponde ao 
   email do empregado que foi retornado pelo serviço.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados/{id}" em seu aplicativo Spring Boot está retornando corretamente um 
empregado específico com base em um ID. Ele configura um cenário com um empregado fictício, simula uma solicitação GET para o endpoint e 
verifica se a resposta tem o status HTTP esperado e se os dados do empregado no corpo da resposta correspondem aos dados do empregado que foram 
retornados pelo serviço. Esse tipo de teste é útil para garantir que a funcionalidade de busca de empregado por ID esteja funcionando conforme 
o esperado.

-------------------- // --------------------

Explicando o método de teste -> testBuscarEmpregadoPorIdNãoEncontrado()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint ao buscar um empregado por ID em um 
aplicativo Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. No entanto, este teste se concentra em um cenário em que 
o empregado não é encontrado (ou seja, a resposta deve indicar que o empregado não foi encontrado). Vou explicar passo a passo o que está 
acontecendo neste método de teste:

```java
void testBuscarEmpregadoPorIdNãoEncontrado() throws Exception {
    // given
    Empregado empregado = criarEmpregado();
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria um objeto `Empregado` chamado `empregado` usando um método 
`criarEmpregado()` (que provavelmente é definido em algum lugar no código de teste). Este objeto `empregado` será usado para simular um empregado 
que será buscado pelo ID.

```java
    given(empregadoServiceMock.getEmpregadoById(empregado.getId())).willReturn(Optional.empty());
```

Nesta parte, o teste configura um comportamento simulado para o serviço `empregadoServiceMock`. Ele usa o método `given()` do Mockito para 
indicar que quando o método `getEmpregadoById()` do serviço é chamado com o ID do `empregado`, ele deve retornar um `Optional` 
vazio (`Optional.empty()`). Isso simula o comportamento de busca de um empregado pelo ID que não é encontrado, ou seja, a busca não retorna 
nenhum resultado.

```java
    // when
    ResultActions response = mockMvc.perform(get("/api/empregados/{id}", empregado.getId()));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação GET para o endpoint 
"/api/empregados/{id}", onde `{id}` é substituído pelo ID do `empregado` criado anteriormente.

```java
    // then
    response.andExpect(status().isNotFound())
    .andDo(print());
```

Na seção "then" do teste, ele verifica o resultado da solicitação que foi enviada:

- `response.andExpect(status().isNotFound())`: Isso verifica se a resposta tem um status HTTP "404 Not Found", que é o status comummente usado 
   para indicar que o recurso solicitado (neste caso, o empregado) não foi encontrado.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados/{id}" em seu aplicativo Spring Boot responde corretamente quando um 
empregado não é encontrado com base em um ID. Ele configura um cenário em que o serviço retorna um `Optional` vazio para simular que o empregado 
não foi encontrado e, em seguida, verifica se a resposta tem o status HTTP esperado (404 Not Found). Isso é útil para garantir que a 
funcionalidade de busca de empregado por ID trate adequadamente os casos em que o empregado não existe.

-------------------- // --------------------

Explicando o método de teste -> testAtualizarEmpregadoPorId()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint para atualizar um empregado por ID em um 
aplicativo Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. Vou explicar passo a passo o que está acontecendo neste 
método de teste:

```java
void testAtualizarEmpregadoPorId() throws Exception {
    // given
    Empregado empregado = criarEmpregado();

    Empregado empregadoAtualizado = Empregado.builder()
            .id(1L)
            .nome("Daniel Up")
            .sobrenome("Penelva Up")
            .email("d4n.andrade@gmail.com").build();
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria dois objetos `Empregado`: `empregado` e `empregadoAtualizado`. 
O `empregado` é criado usando um método `criarEmpregado()` (que provavelmente é definido em algum lugar no código de teste) e representa o estado 
atual do empregado. O `empregadoAtualizado` representa o estado atualizado do empregado, com informações diferentes.

```java
    given(empregadoServiceMock.getEmpregadoById(empregado.getId())).willReturn(Optional.of(empregado));

    given(empregadoServiceMock.updateEmpregado(any(Empregado.class))).willAnswer((invocation) -> invocation.getArgument(0));
```

Nesta parte, o teste configura comportamentos simulados para o serviço `empregadoServiceMock`. 

- O primeiro `given()` indica que quando o método `getEmpregadoById()` do serviço for chamado com o ID do `empregado`, ele deve retornar um 
  `Optional` contendo o objeto `empregado`. Isso simula o comportamento de buscar um empregado pelo ID.

- O segundo `given()` indica que quando o método `updateEmpregado()` do serviço for chamado com qualquer instância de `Empregado`, ele deve 
  retornar exatamente a mesma instância de `Empregado` que foi passada como argumento. Isso simula o comportamento de atualizar um empregado e 
  retornar o empregado atualizado.

```java
    // when
    ResultActions response = mockMvc.perform(put("/api/empregados/{id}", empregado.getId())
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(empregadoAtualizado)));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação PUT para o endpoint 
"/api/empregados/{id}", onde `{id}` é substituído pelo ID do `empregado` que está sendo atualizado. O corpo da solicitação contém os dados do 
`empregadoAtualizado` em formato JSON.

```java
    // then
    response.andExpect(status().isOk())
            .andDo(print())
            .andExpect(jsonPath("$.nome", is(empregadoAtualizado.getNome())))
            .andExpect(jsonPath("$.sobrenome", is(empregadoAtualizado.getSobrenome())))
            .andExpect(jsonPath("$.email", is(empregadoAtualizado.getEmail())));;
```

Na seção "then" do teste, ele verifica o resultado da solicitação que foi enviada:

- `response.andExpect(status().isOk())`: Isso verifica se a resposta tem um status HTTP "200 OK", indicando que a solicitação foi bem-sucedida.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

- `response.andExpect(jsonPath("$.nome", is(empregadoAtualizado.getNome())))`: Isso verifica se o campo "nome" no corpo da resposta JSON 
   corresponde ao nome do `empregadoAtualizado`.

- `response.andExpect(jsonPath("$.sobrenome", is(empregadoAtualizado.getSobrenome())))`: Isso verifica se o campo "sobrenome" no corpo da 
   resposta JSON corresponde ao sobrenome do `empregadoAtualizado`.

- `response.andExpect(jsonPath("$.email", is(empregadoAtualizado.getEmail())))`: Isso verifica se o campo "email" no corpo da resposta JSON 
   corresponde ao email do `empregadoAtualizado`.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados/{id}" em seu aplicativo Spring Boot está atualizando um empregado por 
ID corretamente. Ele configura um cenário com um empregado fictício, simula uma solicitação PUT para o endpoint com dados de empregado atualizados
e verifica se a resposta tem o status HTTP esperado e se os dados do empregado no corpo da resposta correspondem aos dados do empregado 
atualizado. Isso é útil para garantir que a funcionalidade de atualização de empregado por ID esteja funcionando conforme o esperado.


-------------------- // --------------------

Explicando o método de teste -> testAtualizarEmpregadoPorIdNaoEncontrado()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint ao atualizar um empregado por ID em um 
aplicativo Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. No entanto, este teste se concentra em um cenário em que 
o empregado a ser atualizado não é encontrado (ou seja, a resposta deve indicar que o empregado não foi encontrado). Vou explicar passo a passo 
o que está acontecendo neste método de teste:

```java
void testAtualizarEmpregadoPorIdNaoEncontrado() throws Exception {
    // given
    Empregado empregado = criarEmpregado();

    Empregado empregadoAtualizado = Empregado.builder()
            .id(1L)
            .nome("Daniel Up")
            .sobrenome("Penelva Up")
            .email("d4n.andrade@gmail.com").build();
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria dois objetos `Empregado`: `empregado` e `empregadoAtualizado`. 
O `empregado` é criado usando um método `criarEmpregado()` (que provavelmente é definido em algum lugar no código de teste) e representa o estado 
atual do empregado. O `empregadoAtualizado` representa o estado atualizado do empregado, com informações diferentes.

```java
    given(empregadoServiceMock.getEmpregadoById(empregado.getId())).willReturn(Optional.empty());

    given(empregadoServiceMock.updateEmpregado(any(Empregado.class))).willAnswer((invocation) -> invocation.getArgument(0));
```

Nesta parte, o teste configura comportamentos simulados para o serviço `empregadoServiceMock`. 

- O primeiro `given()` indica que quando o método `getEmpregadoById()` do serviço for chamado com o ID do `empregado`, ele deve retornar um 
`Optional` vazio (`Optional.empty()`). Isso simula o comportamento de busca de um empregado pelo ID que não é encontrado, ou seja, a busca não 
retorna nenhum resultado.

- O segundo `given()` indica que quando o método `updateEmpregado()` do serviço for chamado com qualquer instância de `Empregado`, ele deve 
retornar exatamente a mesma instância de `Empregado` que foi passada como argumento. Isso simula o comportamento de atualizar um empregado e 
retornar o empregado atualizado.

```java
    // when
    ResultActions response = mockMvc.perform(put("/api/empregados/{id}", empregado.getId())
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(empregadoAtualizado)));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação PUT para o endpoint 
"/api/empregados/{id}", onde `{id}` é substituído pelo ID do `empregado` que está sendo atualizado. O corpo da solicitação contém os dados do 
`empregadoAtualizado` em formato JSON.

```java
    // then
    response.andExpect(status().isNotFound())
    .andDo(print());
```

Na seção "then" do teste, ele verifica o resultado da solicitação que foi enviada:

- `response.andExpect(status().isNotFound())`: Isso verifica se a resposta tem um status HTTP "404 Not Found", que é o status comumente usado 
   para indicar que o recurso solicitado (neste caso, o empregado) não foi encontrado.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados/{id}" em seu aplicativo Spring Boot responde corretamente quando um 
empregado não é encontrado com base em um ID. Ele configura um cenário em que o serviço retorna um `Optional` vazio para simular que o empregado 
não foi encontrado e, em seguida, verifica se a resposta tem o status HTTP esperado (404 Not Found). Isso é útil para garantir que a 
funcionalidade de atualização de empregado por ID trate adequadamente os casos em que o empregado não existe.

-------------------- // --------------------

Explicando o método de teste -> testDeletarEmpregadoPorId()

Este script é um exemplo de um método de teste de unidade que verifica o comportamento de um endpoint para deletar (remover) um empregado por 
ID em um aplicativo Spring Boot usando o framework Spring MVC e Mockito para simular o serviço. No entanto, neste teste, o cenário é configurado 
de forma diferente em comparação com o exemplo anterior. Vou explicar passo a passo o que está acontecendo neste método de teste:

```java
void testDeletarEmpregadoPorId() throws Exception {
    // given
    Empregado empregado = criarEmpregado();
```

Nesta seção, o teste está configurando o cenário (given) para o teste. Ele cria um objeto `Empregado` chamado `empregado` usando um método 
`criarEmpregado()` e representa o empregado que será excluído.

```java
   doNothing().when(empregadoServiceMock).deleteEmpregado(empregado.getId());
```

Nesta parte, o teste configura um comportamento simulado para o serviço `empregadoServiceMock`.

- `doNothing().when(empregadoServiceMock).deleteEmpregado(empregado.getId());` indica que quando o método `deleteEmpregado()` do serviço for 
chamado com o ID do `empregado`, ele não deve fazer nada (ou seja, não deve realizar nenhuma ação). Isso simula o comportamento de exclusão de 
um empregado, mas na prática, ele não exclui nada. 

Este é um exemplo de como você pode configurar um mock para métodos que não retornam valores ou não têm efeitos colaterais observáveis.

```java
    // when
    ResultActions response = mockMvc.perform(delete("/api/empregados/{id}", empregado.getId()));
```

Nesta parte, o teste executa a ação que está sendo testada (when). Ele usa o objeto `mockMvc` para simular uma solicitação DELETE para o 
endpoint "/api/empregados/{id}", onde `{id}` é substituído pelo ID do `empregado` que está sendo deletado.

```java
    // then
    response.andExpect(status().isOk())
    .andDo(print());
```

Na seção "then" do teste, ele verifica o resultado da solicitação que foi enviada:

- `response.andExpect(status().isOk())`: Isso verifica se a resposta tem um status HTTP "200 OK", indicando que a solicitação de exclusão foi 
   bem-sucedida.

- `response.andDo(print())`: Isso adiciona um manipulador de resultados para imprimir informações de resultado no console, o que é útil para 
   depuração e diagnóstico.

Em resumo, este teste de unidade verifica se o endpoint "/api/empregados/{id}" em seu aplicativo Spring Boot está excluindo um empregado por ID 
corretamente. Ele configura um cenário em que o serviço não realiza nenhuma ação real de exclusão, mas apenas retorna um código de status HTTP 
200 OK para indicar que a solicitação foi bem-sucedida. Esse tipo de teste pode ser útil quando você deseja testar apenas a camada de controle 
do seu aplicativo sem se preocupar com a lógica de negócios real de exclusão no serviço.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Classe TestRestTemplate

A `TestRestTemplate` é uma classe fornecida pelo Spring Framework que faz parte do módulo Spring Test. Ela é usada para testar serviços RESTful 
em um aplicativo Spring durante testes de integração. A principal funcionalidade da `TestRestTemplate` é permitir que você realize chamadas 
HTTP (por exemplo, GET, POST, PUT, DELETE) para seus endpoints REST e verifique as respostas dentro dos testes de integração.

Aqui estão algumas características e informações importantes sobre a classe `TestRestTemplate`:

1. **Integração com o Ambiente Spring**: A `TestRestTemplate` é projetada para funcionar perfeitamente com o ambiente de teste Spring, 
permitindo que você injete dependências gerenciadas pelo Spring, como controladores e serviços, diretamente nos seus testes.

2. **Gerenciamento Automático do Ciclo de Vida do Aplicativo**: O Spring Test Framework cuida do ciclo de vida do aplicativo durante os testes, 
iniciando e encerrando o contexto do Spring conforme necessário. Isso facilita a configuração de um ambiente de teste realista.

3. **Configuração Simples**: Configurar uma instância de `TestRestTemplate` é simples. Você pode simplesmente injetá-la em seus testes e começar a usá-la. O Spring Boot geralmente cria automaticamente uma instância de `TestRestTemplate` configurada para você, a menos que você queira personalizá-la.

4. **Suporte a Autenticação**: A `TestRestTemplate` oferece suporte à autenticação, permitindo que você configure credenciais, como tokens de 
autenticação ou informações de autenticação básica, ao fazer solicitações HTTP para endpoints protegidos.

5. **Manuseio Automático de Serialização e Desserialização**: Ela lida automaticamente com a serialização de objetos Java em formatos como JSON 
ao enviar solicitações e com a desserialização de respostas JSON em objetos Java.

Aqui está um exemplo de uso básico da `TestRestTemplate` em um teste de integração Spring Boot:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringJUnitConfig
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class MyIntegrationTest {

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    void testGetEndpoint() {
        ResponseEntity<String> response = testRestTemplate.getForEntity("/api/resource", String.class);
        assertEquals(200, response.getStatusCodeValue());
        assertEquals("Hello, World!", response.getBody());
    }
}
```

Neste exemplo, o teste de integração injeta uma instância de `TestRestTemplate` e a usa para fazer uma solicitação GET para o endpoint 
"/api/resource". Em seguida, ele verifica o código de status e o corpo da resposta.

A `TestRestTemplate` é uma ferramenta poderosa para testar serviços REST em aplicativos Spring, pois permite que você interaja com seus 
endpoints da mesma forma que um cliente real faria, facilitando a validação do comportamento do seu aplicativo.

-------------------- // --------------------

Explicando o método de teste de integração -> testCriarEmpregado()

1. Começa criando um objeto `Empregado` usando o padrão de construtor Builder. O objeto `empregado` tem um ID de 1, um nome "Daniel", um 
sobrenome "Penelva" e um endereço de e-mail "d4n.andrade@gmail.com".

2. Em seguida, usa `testRestTemplate.postForEntity()` para enviar uma solicitação HTTP POST para o endpoint "http://localhost:8080/api/empregados" 
com o objeto `empregado` como corpo da solicitação. Isso simula a criação de um empregado no servidor.

3. Verifica o código de status da resposta usando `assertEquals()`. Neste caso, espera-se que o código de status seja `HttpStatus.CREATED` 
(HTTP 201), o que significa que a solicitação de criação foi bem-sucedida.

4. Verifica o tipo de mídia (Content-Type) da resposta usando `assertEquals()`. Espera-se que seja `MediaType.APPLICATION_JSON`, que indica 
que a resposta vai ser JSON.

5. Obtém o objeto `Empregado` criado a partir do corpo da resposta usando `resposta.getBody()`.

6. Verifica se o objeto `empregadoCriado` não é nulo usando `assertNotNull()`, garantindo que a criação do empregado tenha sido bem-sucedida e 
que um objeto válido tenha sido retornado.

7. Finalmente, verifica os campos do `empregadoCriado` usando `assertEquals()`, comparando os valores esperados com os valores reais.

No geral, este teste verifica se a criação de um empregado por meio do endpoint "/api/empregados" funciona conforme o esperado, incluindo a 
validação do código de status, tipo de mídia da resposta e os campos do empregado criado. 

-------------------- // --------------------

Explicando o método de teste de integração -> testListarEmpregados()

1. Começa enviando uma solicitação HTTP GET para o endpoint "http://localhost:8080/api/empregados" usando `testRestTemplate.getForEntity()`. A 
resposta é esperada como uma matriz de objetos `Empregado` (`Empregado[]`).

2. Converte o corpo da resposta em uma lista de `Empregado` usando `Arrays.asList(resposta.getBody())`. 

3. Verifica o código de status da resposta usando `assertEquals()`. Neste caso, espera-se que o código de status seja `HttpStatus.OK` (HTTP 200), 
o que significa que a solicitação de listagem de empregados foi bem-sucedida.

4. Verifica o tipo de mídia (Content-Type) da resposta usando `assertEquals()`. Espera-se que seja `MediaType.APPLICATION_JSON`, o que indica 
que a resposta é em formato JSON.

5. Verifica o tamanho da lista de empregados usando `assertEquals()`. Neste caso, espera-se que haja apenas um empregado na lista, portanto, o 
tamanho da lista deve ser igual a 1.

6. Verifica os campos do primeiro empregado na lista, acessando-o através de `empregados.get(0)` e usando `assertEquals()` para comparar os 
valores esperados com os valores reais.

No geral, este teste verifica se a listagem de empregados por meio do endpoint "/api/empregados" retorna um empregado com os valores esperados. 
É um exemplo de teste de integração que valida a funcionalidade de listagem de recursos em um serviço REST em um aplicativo Spring Boot.

-------------------- // --------------------

Explicando o método de teste de integração -> testObterEmpregadosPorId()

1. Começa enviando uma solicitação HTTP GET para o endpoint "http://localhost:8080/api/empregados/1" usando 
`testRestTemplate.getForEntity()`. Isso solicita um empregado específico com o ID 1 e espera receber um objeto `Empregado` como resposta.

2. Obtém o empregado a partir do corpo da resposta usando `resposta.getBody()`.

3. Verifica o código de status da resposta usando `assertEquals()`. Neste caso, espera-se que o código de status seja `HttpStatus.OK` 
(HTTP 200), o que significa que a solicitação de obtenção de empregado foi bem-sucedida.

4. Verifica o tipo de mídia (Content-Type) da resposta usando `assertEquals()`. Espera-se que seja `MediaType.APPLICATION_JSON`, o que 
indica que a resposta é em formato JSON.

5. Verifica se o objeto `empregado` não é nulo usando `assertNotNull()`, garantindo que a obtenção do empregado tenha sido bem-sucedida e 
que um objeto válido tenha sido retornado.

6. Verifica os campos do empregado obtido usando `assertEquals()`, comparando os valores esperados com os valores reais.

No geral, este teste verifica se a obtenção de um empregado por meio do endpoint "/api/empregados/{id}" (onde `{id}` é substituído pelo ID do 
empregado, neste caso, 1) funciona conforme o esperado. Ele valida o código de status da resposta, o tipo de mídia e os campos do empregado 
obtido. 

-------------------- // --------------------

Explicando o método de teste de integração -> testDeletarEmpregados()

1. Começa enviando uma solicitação HTTP GET para listar todos os empregados usando `testRestTemplate.getForEntity()`. A resposta é convertida 
em uma lista de `Empregado`.

2. Verifica se inicialmente há um empregado na lista usando `assertEquals()`. Neste caso, espera-se que haja um empregado na lista.

3. Cria um mapa de variáveis de caminho (`pathVariables`) com o ID do empregado a ser excluído. Neste caso, está configurando o ID como 1.

4. Envia uma solicitação HTTP DELETE para excluir o empregado pelo ID usando `testRestTemplate.exchange()`. Isso simula a exclusão de um 
empregado no servidor.

5. Verifica o código de status da resposta após a exclusão bem-sucedida usando `assertEquals()`. Espera-se que o código de status seja 
`HttpStatus.OK`, indicando que a exclusão foi bem-sucedida.

6. Verifica se a resposta não possui um corpo usando `assertFalse()`, uma vez que uma resposta DELETE bem-sucedida não possui um corpo.

7. Em seguida, envia uma nova solicitação HTTP GET para listar todos os empregados novamente e verifica se a lista de empregados está vazia, já 
que foi excluido o único empregado que estava na lista.

8. Por fim, envia uma solicitação HTTP GET para obter detalhes do empregado com o ID 2 (que não existe mais após a exclusão) e verifica que a 
resposta possui um código de status `HttpStatus.NOT_FOUND`, indicando que o empregado não foi encontrado, e não possui um corpo.

Este teste verifica a funcionalidade de exclusão de empregados por meio do endpoint "/api/empregados/{id}" e também valida o comportamento 
quando um empregado não existe mais após a exclusão. 

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Explicando o método de teste de integração -> testCriarEmpregado()

1. **Dado (given)**: Nesta seção, configura o estado inicial para o teste.

   - Cria um objeto `Empregado` usando o padrão de construtor Builder. O objeto `empregado` tem um ID de 1, um nome "Daniel", um sobrenome 
     "Penelva" e um endereço de e-mail "d4n.andrade@gmail.com".

2. **Quando (when)**: Aqui, executa a ação que deseja testar.

   - Envia uma solicitação HTTP POST usando o `WebTestClient`. A URI é definida como "http://localhost:8080/api/empregados", e o corpo da 
     solicitação contém o objeto `empregado`. Isso simula a criação de um empregado no servidor.

3. **Então (then)**: Nesta seção, verifica os resultados ou o comportamento esperado após a ação.

   - Aqui, usa `expectStatus().isCreated()` para verificar se o código de status da resposta é `HttpStatus.CREATED` (HTTP 201), o que significa 
     que a solicitação de criação foi bem-sucedida.

   - VAqui, usa `expectHeader().contentType(MediaType.APPLICATION_JSON)` para verificar se o cabeçalho de tipo de mídia (Content-Type) da 
     resposta é `MediaType.APPLICATION_JSON`, o que indica que a resposta é em formato JSON.

   - Aqui usa `expectBody()` para verificar o corpo da resposta JSON usando JSONPath.

   - Usando `jsonPath("$.id").isEqualTo(empregado.getId())`, aqui verifica se o campo "id" do empregado criado na resposta corresponde ao ID do 
     empregado que você enviou na solicitação.

   - Da mesma forma, verifica os outros campos do empregado, como nome, sobrenome e email.

Este teste verifica se a criação de um empregado por meio do endpoint "/api/empregados" usando o `WebTestClient` funciona conforme o esperado, 
incluindo a validação do código de status, tipo de mídia da resposta e os campos do empregado criado. É um exemplo de teste de integração usando 
o `WebTestClient` em um aplicativo Spring Boot.

-------------------- // --------------------

Explicando o método de teste de integração -> testBsucarEmpregadoPorId()

1. **Envio da Solicitação GET**: Começa enviando uma solicitação HTTP GET para obter um empregado pelo ID 1 usando `webTestClient.get().uri()`. 
Isso simula a solicitação para buscar um empregado pelo ID.

2. **Verificação do Código de Status**: Verifica o código de status da resposta usando `expectStatus().isOk()`. Isso garante que a resposta 
tenha um código de status HTTP 200 (OK), indicando que a solicitação foi bem-sucedida.

3. **Verificação do Tipo de Mídia**: Verifica o cabeçalho de tipo de mídia (Content-Type) da resposta usando 
`expectHeader().contentType(MediaType.APPLICATION_JSON)`. Isso garante que a resposta seja no formato JSON.

4. **Verificação do Corpo da Resposta JSON**: Aqui, usa `expectBody()` para verificar o corpo da resposta JSON usando JSONPath, que é uma 
linguagem para acessar partes específicas de documentos JSON.

   - `jsonPath("$.id").isEqualTo(1)`: Isso verifica se o campo "id" na resposta JSON é igual a 1, correspondendo ao ID do empregado buscado.

   - `jsonPath("$.nome").isEqualTo("Daniel")`: Isso verifica se o campo "nome" na resposta JSON é igual a "Daniel", correspondendo ao nome do 
      empregado buscado.

   - `jsonPath("$.sobrenome").isEqualTo("Penelva")`: Isso verifica se o campo "sobrenome" na resposta JSON é igual a "Penelva", correspondendo 
      ao sobrenome do empregado buscado.

   - `jsonPath("$.email").isEqualTo("d4n.andrade@gmail.com")`: Isso verifica se o campo "email" na resposta JSON é igual a 
      "d4n.andrade@gmail.com", correspondendo ao email do empregado buscado.

Este teste verifica se a busca de um empregado por meio do endpoint "/api/empregados/{id}" usando o `WebTestClient` funciona conforme o 
esperado. Ele valida o código de status, o tipo de mídia da resposta e os valores dos campos do empregado obtido na resposta JSON. É um exemplo
de teste de integração que verifica a funcionalidade de busca de um único recurso em um serviço REST em um aplicativo Spring Boot.

-------------------- // --------------------

Explicando o método de teste de integração -> testListarEmpregado()

1. **Envio da Solicitação GET**: Começa enviando uma solicitação HTTP GET para listar todos os empregados usando `webTestClient.get().uri()`. 
Isso simula a solicitação para listar todos os empregados.

2. **Verificação do Código de Status**: Verifica o código de status da resposta usando `expectStatus().isOk()`. Isso garante que a resposta 
tenha um código de status HTTP 200 (OK), indicando que a solicitação foi bem-sucedida.

3. **Verificação do Tipo de Mídia**: Verifica o cabeçalho de tipo de mídia (Content-Type) da resposta usando 
`expectHeader().contentType(MediaType.APPLICATION_JSON)`. Isso garante que a resposta seja no formato JSON.

4. **Verificação do Corpo da Resposta JSON**: Aqui, usa `expectBody()` para verificar o corpo da resposta JSON usando JSONPath, que é uma 
linguagem para acessar partes específicas de documentos JSON.

   - `jsonPath("$[0].nome").isEqualTo("Daniel")`: Isso verifica se o campo "nome" do primeiro elemento da matriz JSON é igual a "Daniel".

   - `jsonPath("$[0].sobrenome").isEqualTo("Penelva")`: Isso verifica se o campo "sobrenome" do primeiro elemento da matriz JSON é igual a "Penelva".

   - `jsonPath("$[0].email").isEqualTo("d4n.andrade@gmail.com")`: Isso verifica se o campo "email" do primeiro elemento da matriz JSON é igual 
      a "d4n.andrade@gmail.com".

   - `jsonPath("$").isArray()`: Isso verifica se o corpo da resposta é uma matriz JSON.

   - `jsonPath("$").value(hasSize(1))`: Isso verifica se a matriz JSON tem um tamanho (quantidade de elementos) de 1.

Este teste verifica se a listagem de empregados por meio do endpoint "/api/empregados" usando o `WebTestClient` funciona conforme o esperado. 
Ele valida o código de status, o tipo de mídia da resposta, os valores dos campos do primeiro empregado na resposta JSON, verifica se a resposta 
é uma matriz JSON e verifica o tamanho da matriz JSON. É um exemplo de teste de integração que verifica a funcionalidade de listar todos os 
empregados em um serviço REST em um aplicativo Spring Boot.

-------------------- // --------------------

Explicando o método de teste de integração -> testObterListarEmpregado()

1. **Envio da Solicitação GET**: Começa enviando uma solicitação HTTP GET para listar todos os empregados usando `webTestClient.get().uri()`. 
Isso simula a solicitação para listar todos os empregados.

2. **Verificação do Código de Status**: Verifica o código de status da resposta usando `expectStatus().isOk()`. Isso garante que a resposta 
tenha um código de status HTTP 200 (OK), indicando que a solicitação foi bem-sucedida.

3. **Verificação do Tipo de Mídia**: Verifica o cabeçalho de tipo de mídia (Content-Type) da resposta usando 
`expectHeader().contentType(MediaType.APPLICATION_JSON)`. Isso garante que a resposta seja no formato JSON.

4. **Verificação do Corpo da Resposta JSON como Lista de Empregado**: Aqui, usa `expectBodyList(Empregado.class)` para verificar se o corpo da 
resposta JSON pode ser desserializado em uma lista de objetos `Empregado`. Isso garante que a resposta seja uma lista de empregados em JSON.

5. **Consumir a Resposta e Realizar Verificações Adicionais**: Aqui, usa `consumeWith()` para consumir a resposta e realizar verificações 
adicionais. No lambda passado para `consumeWith()`, você obtém a lista de empregados da resposta usando `response.getResponseBody()` e, em 
seguida, faz duas verificações adicionais:

   - `Assertions.assertNotNull(empregados)`: Isso verifica se a lista de empregados não é nula.

   - `Assertions.assertEquals(1, empregados.size())`: Isso verifica se a lista de empregados tem um tamanho igual a 1.

Este teste verifica se a listagem de empregados por meio do endpoint "/api/empregados" usando o `WebTestClient` funciona conforme o esperado. 
Ele valida o código de status, o tipo de mídia da resposta, a capacidade de desserializar a resposta em uma lista de objetos `Empregado` e 
verifica se a lista de empregados não é nula e tem o tamanho esperado. É um exemplo de teste de integração que verifica a funcionalidade de 
listar todos os empregados em um serviço REST em um aplicativo Spring Boot.

-------------------- // --------------------

Explicando o método de teste de integração -> testAtualizarEmpregado()

1. **Criação do Objeto Empregado Atualizado**: Um objeto `Empregado` chamado `empregadoAtualizado` é criado com os dados que você deseja 
atualizar. Neste caso, o empregado tem ID 1 e dados atualizados de nome, sobrenome e email.

2. **Envio da Solicitação HTTP PUT**: É feita uma solicitação HTTP PUT para o endpoint "http://localhost:8080/api/empregados/1", que é 
responsável por atualizar o empregado com ID 1. O corpo da solicitação contém o objeto `empregadoAtualizado`, que será usado para atualizar o 
empregado existente.

3. **Configuração do Tipo de Mídia**: O cabeçalho de tipo de mídia (Content-Type) da solicitação é configurado como "application/json" para 
indicar que o corpo da solicitação contém dados JSON.

4. **Execução da Solicitação**: A solicitação é efetivamente executada usando o método `.exchange()`.

5. **Verificação do Código de Status**: Após a execução da solicitação, é verificado se o código de status da resposta é HTTP 200 (OK) usando 
`.expectStatus().isOk()`. Isso verifica se a atualização foi bem-sucedida.

6. **Verificação do Cabeçalho de Tipo de Mídia**: É verificado se o cabeçalho de tipo de mídia (Content-Type) da resposta é 
"application/json" usando `.expectHeader().contentType(MediaType.APPLICATION_JSON)`. Isso garante que a resposta seja no formato JSON.

No geral, este teste garante que a atualização de um empregado com dados atualizados seja tratada corretamente pelo endpoint 
"/api/empregados/{id}" usando o método HTTP PUT. Isso é típico de testes de integração que validam a funcionalidade de APIs RESTful em um 
aplicativo Spring Boot.